A typical compiler is a sequence of phases that converts the input programming language into machine code that your computer can actually execute. It has three or four basic phases, depending on how you count.

Parsing

This part of the compiler translates your input text into something usually called an abstract syntax tree, which is a representation (perhaps somewhat but not much simplified) of the literal syntax of your program. This is always, in practice, some sort of hierarchical tree with nodes corresponding to the various syntactic elements of your language: function definitions, variables, constants, statements, expressions of various sorts, while loops, for loops, and so on and so on.

Parsing itself usually usually consists of two parts: 

- lexical analysis or "lexing", which splits up the input characters into meaningful units called tokens, ie, a number, an identifier, a string, and

- parsing itself, which converts the stream of tokens into the syntactic structure of your program, represented as the abstract syntax tree described above.

It's possible to do some simple optimizations at the level of the  AST, in particular things like constant folding (converting 3 + 4 * 2 into 11, and some simple forms of dead code elimination.

Intermediate Representation Generation

At this point, the compiler will convert the abstract syntax tree into an "intermediate representation" or "IR", which will be passed on to the code generator / optimizer. This could be just the AST, but it's much more common to create a set of instructions for a high-level "virtual machine", not in the java sense, just in the sense of an instruction set that's higher level than the actual machine code, and easier for the optimizer to work with.

Overall, these two parts are often called the front end of the compiler.

Next up, the back end...
Dale â€” Today at 09:46
The back end takes the intermediate representation generated by the front end, and is responsible for converting it into efficient machine code.

IR optimization

Most optimizations are done at the level of the intermediate representation. There are literally dozens of optimizations that can be used with names like loop unrolling, function inlining, code hoisting, vectorization, and lots more that I've forgotten over the years. This code tends to be very algorthm heavy, both in the sense of classic data structures like sets, trees, maps, etc, but also in custom representations to enable certain optimizations to be performed efficiently. Even with efficient code, optimization can be the slowest part of the overall compilation phase.

These various optimizations are applied in multiple passes, usually depending on compiler options, and it's a challenge all by itself to decide what order to apply optimizations in since one optimization often conflicts with another to some degree.

Finally, the back end decides it's done enough with the intermediate representation, and moves on to code generation.

Code generation

This is the final phase of a traditional compiler. It converts the intermediate representation (whether it's been optimized or not) correctly into machine code for the target architecture we're generating code for. 

Here, we run into things like instruction selection which can be complicated in itself involving detailed knowledge of the internal architecture of the cpu, including execution pipelines, and register allocation. Register allocation is very important for performance because accessing data in registers is 1000s of times faster than accessing data from memory, but a modern cpu might have a dozen registers available for general use at any one time, and so choosing which variables to put in them is a tricky business.

There are also optimizations that can be done here, that require detailed knowledge of the cpu itself. 


For the front-end of a compiler, the details of lexing and parsing, are mostly a solved problem these days, although they were hot topics of research in the 60s through the 80s. I didn't mention it above, but the front end is also where your syntax errors come from.


https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf